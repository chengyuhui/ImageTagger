// Generated by CoffeeScript 1.6.3
(function() {
  var Q, fs, limitConcurrency, matchFilename, mime, path, removeLongest, throat, tmpl, valid_type, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  path = require('path');

  fs = require('fs');

  mime = require('mime');

  throat = require('throat');

  Q = require('q');

  valid_type = ['image/jpeg', 'image/png'];

  limitConcurrency = function(promiseFactory, limit) {
    var fn;
    fn = throat(limit, promiseFactory);
    return function() {
      return Q(fn.apply(this, arguments));
    };
  };

  removeLongest = function(arr) {
    var i, longestIndex, longestLen, removed, v, _i, _len;
    longestLen = 0;
    longestIndex = 0;
    for (i = _i = 0, _len = arr.length; _i < _len; i = ++_i) {
      v = arr[i];
      if (v == null) {
        continue;
      }
      if (v.length > longestLen) {
        longestIndex = i;
        longestLen = v.length;
      }
    }
    removed = arr[longestIndex];
    delete arr[longestIndex];
    return removed;
  };

  matchFilename = function(fname) {
    var basename, result;
    basename = path.basename(fname, path.extname(fname));
    result = basename.match(/^(\d+)$/);
    if (_.isNull(result)) {
      return false;
    }
    return {
      id: _.last(result),
      ext: path.extname(fname)
    };
  };

  tmpl = _.template('<%= user %> - <%= title %> (<%= work_id %>@<%= user_id %>)[ #<%= tags.join(" ") %> ]');

  module.exports = function(dir, prog, log) {
    var cmd_tmpl, e, fetch, filelist, stat;
    filelist = [];
    try {
      stat = fs.statSync(dir);
      if (!stat.isDirectory()) {
        log.error(null, "" + dir + " is not a directory.");
        process.exit(1);
      }
      filelist = fs.readdirSync(dir);
    } catch (_error) {
      e = _error;
      log.error(null, "Listing files failed: " + e.message);
      process.exit();
    }
    filelist = _.compact(filelist.filter(function(n) {
      var _ref;
      return _ref = mime.lookup(n), __indexOf.call(valid_type, _ref) >= 0;
    }).map(matchFilename));
    if (filelist.length === 0) {
      log.info(null, 'Nothing to do.');
      process.exit();
    }
    log.info(null, "" + filelist.length + " valid file(s) found.");
    fetch = require('./pixiv.fetch');
    log.info(null, "Processing...");
    cmd_tmpl = _.template('<%= user %> - <%= title %> (<%= work_id %>@<%= user_id %>)');
    return Q.allSettled(filelist.map(limitConcurrency(function(file) {
      var id;
      id = file.id;
      return fetch(id).then(function(work) {
        log.info('work', cmd_tmpl(work));
        while (tmpl(work).length > 100 && work.tags.length !== 0) {
          log.warn('tags', "Removing tag " + (removeLongest(work.tags)) + " from work #" + id + ".");
        }
        work.ext = file.ext;
        return work;
      }, function(err) {
        log.error('work', "Failed to fetch #" + id + ": " + err.message);
        throw err;
      });
    }, prog.jobs))).then(function(results) {
      var fail_count, rename, rename_promise, success_count, works;
      fail_count = 0;
      success_count = 0;
      works = _.pluck(results.filter(function(r) {
        if (r.state === "fulfilled") {
          return true;
        } else {
          fail_count += 1;
          return false;
        }
      }), "value");
      if (prog.dry) {
        success_count = works.length;
        log.info("dry-run", "Complete. Success: " + success_count + ", Failed: " + fail_count);
        return;
      }
      log.info(null, "Renaming...");
      rename = Q.nbind(fs.rename);
      rename_promise = works.map(function(w) {
        return rename(path.join(dir, w.work_id + w.ext), path.join(dir, tmpl(w).replace(/[\|\\/:*?"<>]/g, '') + w.ext))["catch"](function(e) {
          log.error("rename", "Failed to rename #" + w.work_id + ": " + e.message);
          throw e;
        });
      });
      return Q.allSettled(rename_promise).then(function(results) {
        return results.forEach(function(r) {
          if (r.state === "fulfilled") {
            return success_count += 1;
          } else {
            return fail_count += 1;
          }
        });
      }).done(function() {
        return log.info("Nya", "Complete. Success: " + success_count + ", Failed: " + fail_count);
      });
    });
  };

}).call(this);

//# sourceMappingURL=pixiv.comm.map
